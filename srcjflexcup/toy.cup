package it.esercitazione4;

import java.util.ArrayList;
import it.esercitazione4.visitor.*;
import java_cup.runtime.*;

parser code {:
       public VisitableNode<Node> makeNode(String name, VisitableNode<Node> ... childrens){
                Node node = new Node(name);
                VisitableNode<Node> toReturn = new VisitableNode<Node>(node);
               for(int i = 0; i < childrens.length; i ++){
                   toReturn.add(childrens[i]);
               }
               return toReturn;
           }

         public VisitableNode<Node> makeNode(String name, ArrayList<VisitableNode<Node>> childrens){

                    Node node = new Node(name);
                    VisitableNode<Node> toReturn = new VisitableNode<Node>(node);

                    for (VisitableNode<Node> nodeChild : childrens)
                       toReturn.add(nodeChild);

                   return toReturn;
            }
 :}

nonterminal VisitableNode<Node> Expr, ExprList, IdList, CallProc, WriteStat, AssignStat, ReadlnStat, Type,
            ResultType,ResultTypeList, ParDecl, IdListInit, ReturnExprs, VarDecl, ParamDeclList, VarDeclList, IfStat,
            ElifList, Elif, Else, WhileStat, StatList, Stat, Proc, Program, ProcList;

terminal SEMI, INT, BOOL, FLOAT, STRING, COMMA, ASSIGN, PROC, LPAR, RPAR, COLON, CORP, VOID, IF, THEN, FI, ELIF, ELSE,
    WHILE, DO, OD, READ, WRITE, TRUE, FALSE, NULL, PLUS, MINUS, TIMES, DIV, AND, OR,
    NOT, GT, GE, NE, LT, LE, EQ, UMINUS, RETURN;

terminal String ID, STRING_CONST;
terminal int INT_CONST;
terminal Double FLOAT_CONST;

precedence left AND, OR;
precedence left GT, GE, NE, LT, LE, EQ;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

Program ::= VarDeclList:vdl ProcList:pl {:RESULT = makeNode(VisitableNode.PROGRAM_OP,vdl,pl);
                                          SyntaxVisitor visitor = new SyntaxVisitor();
                                          //visitor.visit(RESULT);
                                          //visitor.saveFileXML("file.xml");
                                          visitor.myfunc(RESULT);
                                          System.out.println("DONE");
                                          :};

VarDeclList ::=
/* empty */ {: :}
| VarDecl:vd VarDeclList:vds {: ArrayList<VisitableNode<Node>> new_vds = new ArrayList<VisitableNode<Node>>();
                                if(vds != null) {
                                    new_vds.addAll(((ArrayList<VisitableNode<Node>>) vds.data().getValue()));
                                }
                                new_vds.add(0, vd);
                                VisitableNode<Node> vdsNode = makeNode(VisitableNode.VAR_DECL_LIST_OP);
                                vdsNode.data().setValue(new_vds);
                                RESULT = vdsNode;
                                :}
;

ProcList ::= Proc:p {: RESULT = makeNode(VisitableNode.PROC_LIST_OP);
                     ArrayList<VisitableNode<Node>> ps = new ArrayList<VisitableNode<Node>>();
                     ps.add(p);
                     RESULT.data().setValue(ps); :}
	| Proc:p ProcList:ps {: ((ArrayList<VisitableNode<Node>>) ps.data().getValue()).add(0, p);
                        RESULT = ps;
                      :}
;

VarDecl ::= Type:t IdListInit:i SEMI {: RESULT = makeNode(VisitableNode.VAR_DECL_OP, t, i);  :}
;

Type ::= INT {: VisitableNode<Node> node = makeNode(VisitableNode.TYPE_DECL);
                                             node.data().setValue("int");
                                             RESULT = node;  :}
    | BOOL {: VisitableNode<Node> node = makeNode(VisitableNode.TYPE_DECL);
                                             node.data().setValue("bool");
                                             RESULT = node;   :}
    | FLOAT {: VisitableNode<Node> node = makeNode(VisitableNode.TYPE_DECL);
                                             node.data().setValue("float");
                                             RESULT = node;  :}
    | STRING {: VisitableNode<Node> node = makeNode(VisitableNode.TYPE_DECL);
                                             node.data().setValue("string");
                                             RESULT = node;  :}
;
IdListInit ::= ID:id {: RESULT = makeNode(VisitableNode.ID_LIST_INIT_OP);
                        VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                        idNode.data().setValue(id);
                        ArrayList<VisitableNode<Node>> ids = new ArrayList<VisitableNode<Node>>();
                        ids.add(idNode);
                        RESULT.data().setValue(ids); :}
    | IdListInit:i COMMA ID:id {:   VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                    idNode.data().setValue(id);
                                    ((ArrayList<VisitableNode<Node>>) i.data().getValue()).add(idNode);
                                    RESULT = i; :}
    /*int a=5, b, c, d*/
	| ID:id ASSIGN Expr:e {: RESULT = makeNode(VisitableNode.ID_LIST_INIT_OP);
                             VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                             idNode.data().setValue(id);
                             VisitableNode<Node> assignNode = makeNode(VisitableNode.ASSIGN_OP, idNode, e);
                             ArrayList<VisitableNode<Node>> ids = new ArrayList<VisitableNode<Node>>();
                             ids.add(assignNode);
                             RESULT.data().setValue(ids); :}
	/*int a, b=2, c, d*/
	| IdListInit:i COMMA ID:id ASSIGN Expr:e {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                                idNode.data().setValue(id);
                                                VisitableNode<Node> assignNode = makeNode(VisitableNode.ASSIGN_OP, idNode, e);
                                                ((ArrayList<VisitableNode<Node>>) i.data().getValue()).add(assignNode);
                                                RESULT = i; :}
;
Proc ::= PROC ID:id LPAR ParamDeclList:pdl RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:st RETURN ReturnExprs:re CORP SEMI {:
		VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                            idNode.data().setValue(id);
		RESULT = makeNode(VisitableNode.PROC_OP, idNode, pdl, rtl, vdl, st, re);
		:}
	| PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
		VarDeclList:vdl StatList:st RETURN ReturnExprs:re CORP SEMI {:
        VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                              idNode.data().setValue(id);
        RESULT = makeNode(VisitableNode.PROC_OP, idNode, rtl, vdl, st, re);
        :}
    | PROC ID:id LPAR ParamDeclList:pdl RPAR ResultTypeList:rtl COLON
            VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI {:
             VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                 idNode.data().setValue(id);
             RESULT = makeNode(VisitableNode.PROC_OP, idNode, pdl, rtl, vdl, re);
             :}
    | PROC ID:id LPAR RPAR ResultTypeList:rtl COLON
        VarDeclList:vdl RETURN ReturnExprs:re CORP SEMI {:
            VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                  idNode.data().setValue(id);
            RESULT = makeNode(VisitableNode.PROC_OP, idNode, rtl, vdl, re);
            :}
;
ResultTypeList ::= ResultType:rt {: RESULT = makeNode(VisitableNode.RESULT_TYPE_LIST_OP);
                                            ArrayList<VisitableNode<Node>> rts = new ArrayList<VisitableNode<Node>>();
                                            rts.add(rt);
                                            RESULT.data().setValue(rts); :}
	| ResultType:rt COMMA ResultTypeList:rts {: ((ArrayList<VisitableNode<Node>>) rts.data().getValue()).add(0, rt);  :}
;
ReturnExprs::=  ExprList:e {: RESULT = makeNode(VisitableNode.RETURN_EXPRS_OP, e);  :}
	| /* empty */ {: :}
;

ExprList ::= Expr:e {: RESULT = makeNode(VisitableNode.EXPR_LIST_OP);
                       ArrayList<VisitableNode<Node>> expressions = new ArrayList<VisitableNode<Node>>();
                       expressions.add(e);
                       RESULT.data().setValue(expressions); :}
	| Expr:e COMMA ExprList:exprs {: ((ArrayList<VisitableNode<Node>>) exprs.data().getValue()).add(0, e);
	                                RESULT = exprs;
	                              :}
;

ParamDeclList ::= ParDecl:pd {: RESULT = makeNode(VisitableNode.PARAM_DECL_LIST_OP);
                                ArrayList<VisitableNode<Node>> pds = new ArrayList<VisitableNode<Node>>();
                                pds.add(pd);
                                RESULT.data().setValue(pds); :}
    | ParamDeclList:pds SEMI ParDecl:pd {: ((ArrayList<VisitableNode<Node>>) pds.data().getValue()).add(pd);
                                           RESULT = pds;
                                         :}
;

ParDecl ::= Type:t IdList:ids {: RESULT = makeNode(VisitableNode.PAR_DECL_OP, t, ids); :}
;

IdList ::= ID:id {: RESULT = makeNode(VisitableNode.ID_LIST_OP);
                    VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                    idNode.data().setValue(id);
                    ArrayList<VisitableNode<Node>> ids = new ArrayList<VisitableNode<Node>>();
                    ids.add(idNode);
                    RESULT.data().setValue(ids); :}
    | IdList:ids COMMA ID:id {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                idNode.data().setValue(id);
                                ((ArrayList<VisitableNode<Node>>) ids.data().getValue()).add(0, idNode); :}
;

ResultType ::= Type:e {: RESULT = makeNode(VisitableNode.RESULT_TYPE,e);  :}
    | VOID {: VisitableNode<Node> node = makeNode(VisitableNode.TYPE_DECL);
                                         node.data().setValue("void");
                                         RESULT = makeNode(VisitableNode.RESULT_TYPE,node);   :}
;

StatList ::= Stat:e SEMI  {: RESULT = makeNode(VisitableNode.STAT_LIST_OP);
                                     ArrayList<VisitableNode<Node>> stms = new ArrayList<VisitableNode<Node>>();
                                     stms.add(e);
                                     RESULT.data().setValue(stms); :}

    | Stat:st SEMI StatList:stms {: ((ArrayList<VisitableNode<Node>>) stms.data().getValue()).add(0, st);
                               RESULT = stms; :}
;

Stat ::= IfStat:e {: RESULT = e;  :}
	| WhileStat:e {: RESULT = e;  :}
	| ReadlnStat:e {: RESULT = e;  :}
	| WriteStat:e {: RESULT = e;  :}
	| AssignStat:e {: RESULT = e;  :}
	| CallProc:e {: RESULT = e;  :}
;

IfStat ::= IF Expr:e THEN StatList:stms ElifList:els Else:el FI {: RESULT = makeNode(VisitableNode.IF_OP, e, stms, els, el); :}
;

ElifList ::= /* empty */ {: :}
	| Elif:el ElifList:els {: ArrayList<VisitableNode<Node>> new_els = new ArrayList<VisitableNode<Node>>();
                              if(els != null) {
                                  new_els.addAll(((ArrayList<VisitableNode<Node>>) els.data().getValue()));
                              }
                              new_els.add(0, el);
                              VisitableNode<Node> elsNode = makeNode(VisitableNode.ELIF_LIST_OP);
                              elsNode.data().setValue(new_els);
                              RESULT = elsNode;
                              :}
;

Elif ::= ELIF Expr:e THEN StatList:stms {: RESULT = makeNode(VisitableNode.ELIF_OP, e, stms); :}
;

Else ::= /* empty */ {: :}
    | ELSE StatList:stms {: RESULT = makeNode(VisitableNode.ELSE_OP, stms); :}
;

WhileStat ::= WHILE StatList:stms1 RETURN Expr:e DO StatList:stms2 OD {: RESULT = makeNode(VisitableNode.WHILE_OP, stms1, e, stms2); :}
	| WHILE Expr:e DO StatList:stms OD {: RESULT = makeNode(VisitableNode.WHILE_OP, e, stms); :}
;

ReadlnStat ::= READ LPAR IdList:ids RPAR {: RESULT = makeNode(VisitableNode.READ_OP,ids);  :}
;

WriteStat ::=  WRITE LPAR ExprList:exprs RPAR {: RESULT = makeNode(VisitableNode.WRITE_OP,exprs); :}
;

AssignStat ::= IdList:ids ASSIGN  ExprList:exprs {: RESULT = makeNode(VisitableNode.ASSIGN_OP, ids, exprs); :}
;

CallProc ::= ID:id LPAR ExprList:exprs RPAR {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                      idNode.data().setValue(id);
                                      RESULT = makeNode(VisitableNode.CALL_PROC_OP, idNode, exprs); :}
	| ID:id LPAR RPAR {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                         idNode.data().setValue(id);
                         RESULT = makeNode(VisitableNode.CALL_PROC_OP, idNode); :}
;

Expr ::= NULL {: VisitableNode<Node> node = makeNode(VisitableNode.NULL_CONST);
                          	                 node.data().setValue("null");
                          	                 RESULT = node; :}
	| TRUE {: VisitableNode<Node> node = makeNode(VisitableNode.TRUE_CONST);
                                        	                 node.data().setValue("true");
                                        	                 RESULT = node;  :}
	| FALSE {: VisitableNode<Node> node = makeNode(VisitableNode.FALSE_CONST);
                                         	                 node.data().setValue("false");
                                         	                 RESULT = node;  :}
	| INT_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.INT_CONST);
	                 node.data().setValue(e);
	                 RESULT = node; :}
	| FLOAT_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.FLOAT_CONST);
                    	                 node.data().setValue(e);
                    	                 RESULT = node; :}
	| STRING_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.STRING_CONST);
                     	                 node.data().setValue(e);
                     	                 RESULT = node; :}
	| ID:e {: VisitableNode<Node> node = makeNode(VisitableNode.ID);
           	                 node.data().setValue(e);
           	                 RESULT = node; :}
    | CallProc:e {: RESULT = e;  :}
	| Expr:e1 PLUS Expr:e2 {: RESULT = makeNode(VisitableNode.ADD_OP,e1,e2); :}
	| Expr:e1 MINUS Expr:e2 {: RESULT = makeNode(VisitableNode.DIFF_OP,e1,e2); :}
	| Expr:e1 TIMES Expr:e2 {: RESULT = makeNode(VisitableNode.MUL_OP,e1,e2); :}
	| Expr:e1 DIV Expr:e2 {: RESULT = makeNode(VisitableNode.DIV_OP,e1,e2); :}
	| Expr:e1 AND Expr:e2 {: RESULT = makeNode(VisitableNode.AND_OP,e1,e2); :}
	| Expr:e1 OR Expr:e2 {: RESULT = makeNode(VisitableNode.OR_OP,e1,e2); :}
	| Expr:e1 GT Expr:e2 {: RESULT = makeNode(VisitableNode.GT_OP,e1,e2); :}
	| Expr:e1 GE Expr:e2 {: RESULT = makeNode(VisitableNode.GE_OP,e1,e2); :}
	| Expr:e1 LT Expr:e2 {: RESULT = makeNode(VisitableNode.LT_OP,e1,e2); :}
	| Expr:e1 LE Expr:e2 {: RESULT = makeNode(VisitableNode.LE_OP,e1,e2); :}
	| Expr:e1 EQ Expr:e2 {: RESULT = makeNode(VisitableNode.EQ_OP,e1,e2); :}
	| Expr:e1 NE Expr:e2 {: RESULT = makeNode(VisitableNode.NE_OP,e1,e2);  :}
	| MINUS Expr:e {: RESULT = makeNode(VisitableNode.UMINUS_OP,e);  :} %prec UMINUS
	| NOT Expr:e {: RESULT = makeNode(VisitableNode.NOT_OP,e);  :}
;
