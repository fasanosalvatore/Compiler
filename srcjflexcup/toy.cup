package it.esercitazione4;

import java.util.ArrayList;
import it.esercitazione4.visitor.*;
import java_cup.runtime.*;

parser code {:
       public VisitableNode<Node> makeNode(String name, VisitableNode<Node> ... childrens){
                Node node = new Node(name);
                VisitableNode<Node> toReturn = new VisitableNode<Node>(node);
               for(int i = 0; i < childrens.length; i ++){
                   toReturn.add(childrens[i]);
               }
               return toReturn;
           }

         public VisitableNode<Node> makeNode(String name, ArrayList<VisitableNode<Node>> childrens){

                    Node node = new Node(name);
                    VisitableNode<Node> toReturn = new VisitableNode<Node>(node);

                    for (VisitableNode<Node> nodeChild : childrens)
                       toReturn.add(nodeChild);

                   return toReturn;
            }
 :}

nonterminal Program, VarDeclList, ProcList, VarDecl, Type, IdListInit, Proc, ResultTypeList, ReturnExprs, ExprList,
    ParamDeclList, ParDecl, IdList, ResultType, StatList, Stat, IfStat, ElifList, Elif, Else, WhileStat, ReadlnStat,
    WriteStat, AssignStat, CallProc ;

terminal SEMI, INT, BOOL, FLOAT, STRING, COMMA, ASSIGN, PROC, LPAR, RPAR, COLON, CORP, VOID, IF, THEN, FI, ELIF, ELSE,
    WHILE, DO, OD, READ, WRITE, TRUE, FALSE, NULL, PLUS, MINUS, TIMES, DIV, AND, OR,
    NOT, GT, GE, NE, LT, LE, EQ, UMINUS, RETURN;

nonterminal VisitableNode<Node> Expr;

terminal String ID, STRING_CONST;
terminal int INT_CONST;
terminal Double FLOAT_CONST;

precedence left AND, OR;
precedence left GT, GE, NE, LT, LE, EQ;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;

Program ::= VarDeclList ProcList {: RESULT = 0;  :};

VarDeclList ::=
/* empty */ {: RESULT = 0;  :}
| VarDecl VarDeclList {: RESULT = 0;  :}
;

ProcList ::= Proc {: RESULT = 0;  :}
	| Proc ProcList {: RESULT = 0;  :}
;
VarDecl ::= Type IdListInit SEMI {: RESULT = 0;  :}
;
Type ::= INT {: RESULT = 0;  :}
    | BOOL {: RESULT = 0;  :}
    | FLOAT {: RESULT = 0;  :}
    | STRING {: RESULT = 0;  :}
;
IdListInit ::= ID {: RESULT = 0;  :}
	| IdListInit COMMA ID {: RESULT = 0;  :}
	| ID ASSIGN Expr {: RESULT = 0;  :}
	| IdListInit COMMA ID ASSIGN Expr {: RESULT = 0;  :}
;
Proc ::= PROC ID LPAR ParamDeclList RPAR ResultTypeList COLON
		VarDeclList StatList RETURN ReturnExprs CORP SEMI {: RESULT = 0;  :}
	| PROC ID LPAR RPAR ResultTypeList COLON
		VarDeclList StatList RETURN ReturnExprs CORP SEMI {: RESULT = 0;  :}
    | PROC ID LPAR ParamDeclList RPAR ResultTypeList COLON
            VarDeclList RETURN ReturnExprs CORP SEMI {: RESULT = 0;  :}
    | PROC ID LPAR RPAR ResultTypeList COLON
        VarDeclList RETURN ReturnExprs CORP SEMI {: RESULT = 0;  :}
;
ResultTypeList ::= ResultType {: RESULT = 0;  :}
	| ResultType COMMA ResultTypeList {: RESULT = 0;  :}
;
ReturnExprs::=  ExprList {: RESULT = 0;  :}
	| /* empty */ {: RESULT = 0;  :}
;
ExprList ::= Expr {: RESULT = 0;  :}
	| Expr COMMA ExprList {: RESULT = 0;  :}
;
ParamDeclList ::= ParDecl {: RESULT = 0;  :}
    | ParamDeclList SEMI ParDecl {: RESULT = 0;  :}
;
ParDecl ::= Type IdList {: RESULT = 0;  :}
;
IdList ::= ID {: RESULT = 0;  :}
    | IdList COMMA ID {: RESULT = 0;  :}
;
ResultType ::= Type {: RESULT = 0;  :}
    | VOID {: RESULT = 0;  :}
;
StatList ::= Stat  {: RESULT = 0;  :}
    | Stat StatList {: RESULT = 0;  :}
;
Stat ::= IfStat SEMI {: RESULT = 0;  :}
	| WhileStat SEMI {: RESULT = 0;  :}
	| ReadlnStat SEMI {: RESULT = 0;  :}
	| WriteStat SEMI {: RESULT = 0;  :}
	| AssignStat SEMI {: RESULT = 0;  :}
	| CallProc SEMI {: RESULT = 0;  :}
;
IfStat ::= IF Expr THEN StatList ElifList Else FI {: RESULT = 0;  :}
;

ElifList ::= /* empty */ {: RESULT = 0;  :}
	| Elif ElifList {: RESULT = 0;  :}
;

Elif ::= ELIF Expr THEN StatList {: RESULT = 0;  :}
;

Else ::= /* empty */ {: RESULT = 0;  :}
    | ELSE StatList {: RESULT = 0;  :}
;

WhileStat ::= WHILE StatList RETURN Expr DO StatList OD {: RESULT = 0;  :}
	| WHILE Expr DO StatList OD {: RESULT = 0;  :}
;

ReadlnStat ::= READ LPAR IdList RPAR {: RESULT = 0;  :}
;

WriteStat ::=  WRITE LPAR ExprList RPAR {: RESULT = 0;  :}
;

AssignStat ::= IdList ASSIGN  ExprList {: RESULT = 0;  :}
;

CallProc ::= ID:id LPAR ExprList:exprs RPAR {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                                      node.setValue(id);
                                      RESULT = makeNode(VisitableNode.CALL_PROC_OP, idNode, exprs); :}
	| ID:id LPAR RPAR {: VisitableNode<Node> idNode = makeNode(VisitableNode.ID);
                         node.setValue(id);
                         RESULT = makeNode(VisitableNode.CALL_PROC_OP, idNode); :}
;

Expr ::= NULL {: RESULT = makeNode(VisitableNode.NULL_CONST,"null"); :}
	| TRUE {: RESULT = makeNode(VisitableNode.TRUE_CONST,"true");  :}
	| FALSE {: RESULT = makeNode(VisitableNode.FALSE_CONST, "false");  :}
	| INT_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.INT_CONST);
	                 node.setValue(e);
	                 RESULT = node; :}
	| FLOAT_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.FLOAT_CONST);
                    	                 node.setValue(e);
                    	                 RESULT = node; :}
	| STRING_CONST:e {: VisitableNode<Node> node = makeNode(VisitableNode.STRING_CONST);
                     	                 node.setValue(e);
                     	                 RESULT = node; :}
	| ID:e {: VisitableNode<Node> node = makeNode(VisitableNode.ID);
           	                 node.setValue(e);
           	                 RESULT = node; :}
    | CallProc:e {: RESULT = e;  :}
	| Expr:e1 PLUS Expr:e2 {: RESULT = makeNode(VisitableNode.ADD_OP,e1,e2); :}
	| Expr:e1 MINUS Expr:e2 {: RESULT = makeNode(VisitableNode.DIFF_OP,e1,e2); :}
	| Expr:e1 TIMES Expr:e2 {: RESULT = makeNode(VisitableNode.MUL_OP,e1,e2); :}
	| Expr:e1 DIV Expr:e2 {: RESULT = makeNode(VisitableNode.DIV_OP,e1,e2); :}
	| Expr:e1 AND Expr:e2 {: RESULT = makeNode(VisitableNode.AND_OP,e1,e2); :}
	| Expr:e1 OR Expr:e2 {: RESULT = makeNode(VisitableNode.OR_OP,e1,e2); :}
	| Expr:e1 GT Expr:e2 {: RESULT = makeNode(VisitableNode.GT_OP,e1,e2); :}
	| Expr:e1 GE Expr:e2 {: RESULT = makeNode(VisitableNode.GE_OP,e1,e2); :}
	| Expr:e1 LT Expr:e2 {: RESULT = makeNode(VisitableNode.LT_OP,e1,e2); :}
	| Expr:e1 LE Expr:e2 {: RESULT = makeNode(VisitableNode.LE_OP,e1,e2); :}
	| Expr:e1 EQ Expr:e2 {: RESULT = makeNode(VisitableNode.EQ_OP,e1,e2); :}
	| Expr:e1 NE Expr:e2 {: RESULT = makeNode(VisitableNode.NE_OP,e1,e2);  :}
	| MINUS Expr:e {: RESULT = makeNode(VisitableNode.UMINUS_OP,e);  :} %prec UMINUS
	| NOT Expr:e {: RESULT = makeNode(VisitableNode.NOT_OP,e);  :}
;
